
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/Science.ipynb

import warnings
warnings.filterwarnings('ignore')
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pickle
from collections import OrderedDict
from scipy.optimize import minimize
from numpy.random import multivariate_normal
from scipy.special import erf
from scipy.integrate import quad
import matplotlib.pyplot as plt
from numpy.linalg import inv
from scipy.stats import chi2


from pathlib import Path
Path.ls = lambda p: [i for i in p.iterdir()]

def pickleLoad(fname):
    with open(fname,'rb') as f:
        return pickle.load(f)

def pickleDump(fname,obj):
    with open(fname,'wb') as f:
        pickle.dump(obj,f,pickle.HIGHEST_PROTOCOL)

def toeplitzMATLAB(a,n):
    a_m = a[::-1]
    a_n = a[:n]
    return np.flipud(toeplitz(a_m,a_n))

def fullDisplay(df,max_rows=None,max_col=None,width=None):
    df_cp = df.style.set_properties( **{'width': f'{width}px'}) if width is not None else df.copy()
    with pd.option_context('display.max_rows', max_rows, 'display.max_columns', max_col,):
        display(df_cp)

r0_str = r'$R_0$'
R0_str = r'$R_0$'
gamma_str = r'$\gamma^{-1}$'

from scipy.signal import correlate
from scipy.linalg import toeplitz

JHU_dir = './JHU/COVID-19'
JHU_path = Path(f'./{JHU_dir}/csse_covid_19_data/csse_covid_19_time_series/')
JHU_confirmed_path = Path(f'./{JHU_dir}/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv')
JHU_death_path = Path(f'./{JHU_dir}/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv')
JHU_recovered_path = Path(f'./{JHU_dir}/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_recovered_global.csv')

JHU_confirmed_df = pd.read_csv(JHU_confirmed_path);
JHU_death_df = pd.read_csv(JHU_death_path);
JHU_recovered_df = pd.read_csv(JHU_recovered_path);

JHU_dfs = {'confirmed':JHU_confirmed_df,'death':JHU_death_df,'recovered':JHU_recovered_df}

NYT_us_cases = pd.read_csv('/opt/genomics/Jupyter_Notebook/NadavRakocz/covid19/NYT_output/time_series_us_cases_NYT.csv')

data = {}

def findBestShift(train_case,simcases,test_case=None,
                  train_death=None,simdeath=None,test_death=None,
                  testingperiod=7,debug=False,DEATH_REG = 0.1,loss='mse',norm=False):

    EPS = 500
    n_sim = len(simcases)
    trainingperiod = len(train_case)
    testingperiod = len(test_case) if test_case is not None else 0
    if train_death is not None: ratio = train_case[-1]/train_death[-1]

    losses = []
    rel_errs = []
    test_rel_errs = []
    smooth_test_rel_errs = []
    alphas = []
    e = np.sum(train_case**2)
    loss_func = tailwMSE if loss=='tail' else MSE if loss=='mse' else ll_prof

#     train_case_m = train_case - train_case.mean()
#     simcases_toeplitz = toeplitzMATLAB(simcases,len(train_case))


    for i in range(n_sim-trainingperiod-testingperiod):
        y=simcases[i:i+trainingperiod]
        if(not norm):
            alpha=1
        else:
#             alpha = np.sum(y*train_case)/e if np.sum(y)>EPS else 1
            alpha = max(0.3,np.sum(y*train_case)/e)
        alphas.append(alpha)
        loss_case = loss_func(alpha*train_case,y)
        case_rel_err = np.abs((train_case[-1]-y[-1])/train_case[-1])




        # adding death fit
        if train_death is not None:
            loss_death = loss_func(train_death,y)
            loss = loss_case/ratio**2 + DEATH_REG*loss_death
        else:
             loss = loss_case

        losses.append(loss)
        rel_errs.append(case_rel_err)

        # for prediction
        if(test_case is not None):
            delta = y[-1] - train_case[-1]
            smooth_test_pred = simcases[i+trainingperiod +testingperiod -1] - delta
            smooth_test_rel_err = np.abs((test_case[-1]-smooth_test_pred)/test_case[-1])

            test_rel_err = np.abs((test_case[-1]-simcases[i+trainingperiod +testingperiod -1])/test_case[-1])
            test_rel_errs.append(test_rel_err)
            smooth_test_rel_errs.append(smooth_test_rel_err)


    if(debug):plt.plot(losses)
    best_shift = np.argmin(losses)

    if(test_case is None):
        return (losses[best_shift],best_shift,rel_errs[best_shift],None,None,alphas[best_shift])
    return (losses[best_shift],best_shift,rel_errs[best_shift],test_rel_errs[best_shift],smooth_test_rel_errs[best_shift],alphas[best_shift])


def tailwMSE(true,pred,ws=3,w=10):
    loss = (true-pred)**2
    ones = np.ones(loss.shape)
    ones[-ws:] = w # [1,1,...,100,100,100]
    return loss.T@ones

def MSE(true,pred):
    loss = np.mean((true-pred)**2)
    return loss

def ll_prof(true,pred):
    T = len(pred)
    return (T/2)*np.log(np.mean((true-pred)**2))